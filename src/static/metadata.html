<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Criador de Metadados NFT com Análise de Sentimentos - Chainlink Functions</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --dark-blue: #0f0b2a;
            --medium-blue: #1a1642;
            --light-blue: #4e9fff;
            --purple: #8a56ff;
            --cyan: #56d6ff;
            --pink: #ff56d6;
            --orange: #ff8a56;
            --yellow: #ffdd56;
        }
        
        body {
            background-color: var(--dark-blue);
            color: white;
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1000px;
            margin-top: 30px;
        }
        
        .card {
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            border: none;
            background-color: var(--medium-blue);
            color: white;
        }
        
        .btn-primary {
            background: linear-gradient(45deg, var(--light-blue), var(--purple));
            border: none;
            border-radius: 10px;
            padding: 12px 24px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(78, 159, 255, 0.3);
        }
        
        .btn-secondary {
            background: linear-gradient(45deg, var(--cyan), var(--pink));
            border: none;
            border-radius: 10px;
            padding: 12px 24px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(86, 214, 255, 0.3);
        }
        
        .form-control {
            background-color: var(--dark-blue);
            border: 2px solid var(--light-blue);
            color: white;
            border-radius: 10px;
        }
        
        .form-control:focus {
            background-color: var(--dark-blue);
            border-color: var(--purple);
            color: white;
            box-shadow: 0 0 0 0.2rem rgba(138, 86, 255, 0.25);
        }
        
        .loading-spinner {
            display: none;
            text-align: center;
            color: var(--light-blue);
        }
        
        .analysis-section {
            background: linear-gradient(135deg, var(--medium-blue), var(--dark-blue));
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--light-blue);
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        
        .status-connected {
            background-color: #28a745;
        }
        
        .status-disconnected {
            background-color: #dc3545;
        }
        
        .debug-info {
            background-color: var(--dark-blue);
            border: 1px solid var(--light-blue);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            display: none;
        }
        
        .preview-card {
            background: linear-gradient(135deg, var(--purple), var(--pink));
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 2px solid var(--cyan);
        }
        
        .preview-item {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .preview-item h5 {
            color: var(--yellow);
            margin-bottom: 10px;
        }
        
        .gas-config {
            background-color: var(--dark-blue);
            border: 2px solid var(--orange);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .gas-config h6 {
            color: var(--orange);
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-center mb-4">
            <i class="fas fa-robot me-2"></i>
            Criador de Metadados NFT com Análise de Sentimentos
            <br><small class="text-muted">Powered by Chainlink Functions & OpenAI</small>
        </h1>

        <!-- Status da Carteira e Contrato -->
        <div class="card">
            <div class="card-header">
                <h3><i class="fas fa-wallet me-2"></i>Status da Conexão</h3>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <p><span class="status-indicator status-disconnected" id="wallet-status-indicator"></span>
                        <span id="wallet-status-text">Carteira não conectada</span></p>
                        <button id="connect-wallet-btn" class="btn btn-primary">
                            <i class="fas fa-link me-2"></i>Conectar Carteira
                        </button>
                    </div>
                    <div class="col-md-6">
                        <p><span class="status-indicator status-disconnected" id="contract-status-indicator"></span>
                        <small>Contrato Chainlink: <span id="chainlink-status-display">Não configurado</span></small></p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Configurações de Contratos e Gas -->
        <div class="card">
            <div class="card-header">
                <h3><i class="fas fa-cog me-2"></i>Configurações</h3>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6 mb-3">
                        <label for="contract-address" class="form-label">Endereço do Contrato NFT:</label>
                        <input type="text" class="form-control" id="contract-address" value="0xC1B247Ea8DaE4912Bf4216A6E8954aa90C779ABD">
                    </div>
                    <div class="col-md-6 mb-3">
                        <label for="chainlink-contract-address" class="form-label">Contrato Chainlink Functions:</label>
                        <input type="text" class="form-control" id="chainlink-contract-address" placeholder="0x..." value="0xe9BcC769fd339B30d18aD2c3558C59DF5F8EC2eB">
                    </div>
                </div>
                
                <!-- Configurações de Gas -->
                <div class="gas-config">
                    <h6><i class="fas fa-fire me-2"></i>Configurações de Gas</h6>
                    <div class="row">
                        <div class="col-md-4">
                            <label for="gas-limit" class="form-label">Gas Limit:</label>
                            <input type="number" class="form-control" id="gas-limit" value="15000000" min="1000000" max="30000000">
                        </div>
                        <div class="col-md-4">
                            <label for="gas-price" class="form-label">Gas Price (Gwei):</label>
                            <input type="number" class="form-control" id="gas-price" value="25" min="1" max="100">
                        </div>
                        <div class="col-md-4">
                            <label for="subscription-id" class="form-label">Subscription ID:</label>
                            <input type="number" class="form-control" id="subscription-id" value="15580">
                        </div>
                    </div>
                    <small class="text-muted">
                        <i class="fas fa-info-circle me-1"></i>
                        Ajuste o Gas Limit se encontrar erros de "execution reverted"
                    </small>
                </div>
            </div>
        </div>

        <!-- Upload de Imagem -->
        <div class="card">
            <div class="card-header">
                <h3><i class="fas fa-upload me-2"></i>Upload de Imagem</h3>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label for="image-upload" class="form-label">Selecione uma imagem para análise:</label>
                    <input type="file" class="form-control" id="image-upload" accept="image/*">
                </div>
                
                <div class="row">
                    <div class="col-md-6">
                        <button id="upload-btn" class="btn btn-primary btn-lg w-100 mb-2">
                            <i class="fas fa-brain me-2"></i>
                            Fazer Upload e Analisar com Chainlink Functions
                        </button>
                    </div>
                    <div class="col-md-6">
                        <button id="preview-btn" class="btn btn-secondary btn-lg w-100 mb-2" style="display: none;">
                            <i class="fas fa-eye me-2"></i>
                            Pré-visualizar Análise (Direto Backend)
                        </button>
                    </div>
                </div>
                
                <!-- Loading Spinner -->
                <div id="loading-spinner" class="loading-spinner mt-3">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Carregando...</span>
                    </div>
                    <p class="mt-2" id="loading-text">Processando...</p>
                </div>
            </div>
        </div>

        <!-- Imagem Carregada -->
        <div class="card" id="image-preview" style="display: none;">
            <div class="card-header">
                <h3><i class="fas fa-image me-2"></i>Imagem Carregada</h3>
            </div>
            <div class="card-body text-center">
                <img id="uploaded-image" class="img-fluid" alt="Imagem carregada" style="max-height: 400px; border-radius: 10px;">
                <p class="mt-2">
                    <small class="text-muted">
                        IPFS Hash: <span id="ipfs-hash"></span>
                    </small>
                </p>
            </div>
        </div>

        <!-- Pré-visualização da Análise -->
        <div id="analysis-preview" style="display: none;">
            <div class="preview-card">
                <h3 class="text-center mb-4">
                    <i class="fas fa-search me-2"></i>Pré-visualização da Análise de Sentimentos
                </h3>
                <div id="preview-content">
                    <!-- Conteúdo será preenchido dinamicamente -->
                </div>
                <div class="text-center mt-4">
                    <button id="confirm-analysis-btn" class="btn btn-primary btn-lg">
                        <i class="fas fa-check me-2"></i>
                        Confirmar e Executar via Chainlink Functions
                    </button>
                </div>
            </div>
        </div>

        <!-- Resultados da Análise -->
        <div id="analysis-results" style="display: none;">
            <div class="analysis-section">
                <h3 class="text-center mb-4">
                    <i class="fas fa-chart-line me-2"></i>Resultados da Análise de Sentimentos
                </h3>
                <div id="sentiment-result"></div>
                <div id="color-result"></div>
                <div id="symbol-result"></div>
                <div id="visual-result"></div>
                <div id="keywords-result"></div>
                <div id="attributes-result"></div>
            </div>
        </div>

        <!-- Criação de Metadados -->
        <div class="card" id="metadata-section" style="display: none;">
            <div class="card-header">
                <h3><i class="fas fa-magic me-2"></i>Criação de Metadados e NFT</h3>
            </div>
            <div class="card-body">
                <button id="create-metadata-btn" class="btn btn-primary btn-lg w-100">
                    <i class="fas fa-magic me-2"></i>
                    Criar Metadados e Mintar NFT
                </button>
            </div>
        </div>

        <!-- Informações de Depuração -->
        <div class="mt-3">
            <button id="toggle-debug" class="btn btn-sm btn-outline-secondary">
                <i class="fas fa-bug me-2"></i>Mostrar/Ocultar Informações de Depuração
            </button>
            <div id="debug-info" class="debug-info"></div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script>
        // ABI do contrato Chainlink Functions
        const CHAINLINK_FUNCTIONS_ABI = [
            {
                "inputs": [
                    {"internalType": "uint64", "name": "subscriptionId", "type": "uint64"},
                    {"internalType": "string[]", "name": "args", "type": "string[]"}
                ],
                "name": "sendRequest",
                "outputs": [{"internalType": "bytes32", "name": "requestId", "type": "bytes32"}],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "internalType": "bytes32", "name": "requestId", "type": "bytes32"},
                    {"indexed": false, "internalType": "string", "name": "sentimentAnalysis", "type": "string"},
                    {"indexed": false, "internalType": "string", "name": "colorPsychology", "type": "string"},
                    {"indexed": false, "internalType": "string", "name": "symbolRelation", "type": "string"},
                    {"indexed": false, "internalType": "string", "name": "visualLanguage", "type": "string"},
                    {"indexed": false, "internalType": "string", "name": "keywords", "type": "string"},
                    {"indexed": false, "internalType": "string", "name": "attributes", "type": "string"},
                    {"indexed": false, "internalType": "bytes", "name": "response", "type": "bytes"},
                    {"indexed": false, "internalType": "bytes", "name": "err", "type": "bytes"}
                ],
                "name": "Response",
                "type": "event"
            }
        ];

        // Variáveis globais
        let currentProvider = null;
        let currentSigner = null;
        let chainlinkContract = null;
        let currentImageHash = null;
        //20250617 - linha abaixo comentada para evitar erro de variável não definida - duplicada
        //let previewAnalysis = null;
        
        // Função para logar mensagens de depuração
        function logDebugMessage(message) {
            const debugInfo = document.getElementById('debug-info');
            const timestamp = new Date().toLocaleTimeString();
            debugInfo.innerHTML += `[${timestamp}] ${message}<br>`;
            debugInfo.scrollTop = debugInfo.scrollHeight;
            console.log(`[${timestamp}] ${message}`);
        }

        // Verificar conexão da carteira
        async function checkWalletConnection() {
            logDebugMessage("Checking wallet connection...");
            if (typeof window.ethereum !== 'undefined') {
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                    if (accounts.length > 0) {
                        updateWalletStatus(true, accounts[0]);
                        logDebugMessage(`Wallet connected: ${accounts[0]}`);
                        await initializeProvider();
                    } else {
                        logDebugMessage("Wallet not connected (no accounts found).");
                        updateWalletStatus(false);
                    }
                } catch (error) {
                    logDebugMessage(`Error checking wallet: ${error.message}`);
                    console.error('Erro ao verificar carteira:', error);
                    updateWalletStatus(false);
                }
            } else {
                logDebugMessage("MetaMask (window.ethereum) not detected.");
                updateWalletStatus(false);
            }
        }

        // Conectar carteira
        async function connectWallet() {
            logDebugMessage("Attempting to connect wallet...");
            if (typeof window.ethereum !== 'undefined') {
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    if (accounts.length > 0) {
                        updateWalletStatus(true, accounts[0]);
                        logDebugMessage(`Wallet connected successfully: ${accounts[0]}`);
                        await initializeProvider();
                    }
                } catch (error) {
                    logDebugMessage(`Error connecting wallet: ${error.message}`);
                    console.error('Erro ao conectar carteira:', error);
                }
            } else {
                logDebugMessage("MetaMask not detected. Please install MetaMask.");
                alert('MetaMask não detectado. Por favor, instale a extensão MetaMask para usar este dApp.');
            }
        }

        // Inicializar provider e contrato Chainlink Functions
        async function initializeProvider() {
            logDebugMessage("Initializing provider and Chainlink contract...");
            try {
                if (typeof window.ethereum === 'undefined') {
                    logDebugMessage("window.ethereum is undefined. Cannot initialize provider.");
                    return;
                }

                if (typeof ethers === 'undefined') {
                    logDebugMessage("ethers library is not loaded. Cannot initialize provider.");
                    return;
                }

                currentProvider = new ethers.providers.Web3Provider(window.ethereum);
                currentSigner = currentProvider.getSigner();
                logDebugMessage("Provider and signer initialized successfully.");

                const chainlinkContractAddressInput = document.getElementById('chainlink-contract-address');
                const contractAddress = chainlinkContractAddressInput.value;

                if (contractAddress && contractAddress.length === 42 && contractAddress.startsWith('0x')) {
                    chainlinkContract = new ethers.Contract(contractAddress, CHAINLINK_FUNCTIONS_ABI, currentSigner);
                    logDebugMessage(`Chainlink Contract initialized with address: ${contractAddress}`);
                    
                    // Atualizar status do contrato
                    document.getElementById('chainlink-status-display').textContent = `${contractAddress.substring(0, 6)}...${contractAddress.substring(contractAddress.length - 4)}`;
                    document.getElementById('contract-status-indicator').className = 'status-indicator status-connected';
                    
                    // Configurar listener para eventos
                    setupEventListener();
                } else {
                    logDebugMessage(`Invalid Chainlink Contract Address: ${contractAddress}`);
                    document.getElementById('chainlink-status-display').textContent = 'Endereço inválido';
                    document.getElementById('contract-status-indicator').className = 'status-indicator status-disconnected';
                }
            } catch (error) {
                logDebugMessage(`Error initializing provider or contract: ${error.message}`);
                console.error('Erro ao inicializar provider:', error);
            }
        }

        // Configurar listener para eventos do contrato
        function setupEventListener() {
            if (chainlinkContract) {
                logDebugMessage("Setting up contract event listener...");
                chainlinkContract.on("Response", (requestId, sentimentAnalysis, colorPsychology, symbolRelation, visualLanguage, keywords, attributes, response, err) => {
                    logDebugMessage(`Response event received for request: ${requestId}`);
                    hideLoading();
                    displayAnalysisResults(sentimentAnalysis, colorPsychology, symbolRelation, visualLanguage, keywords, attributes);
                    document.getElementById('metadata-section').style.display = 'block';
                });
            }
        }

        // Atualizar status da carteira
        function updateWalletStatus(connected, address = '') {
            const statusIndicator = document.getElementById('wallet-status-indicator');
            const statusText = document.getElementById('wallet-status-text');
            
            if (connected) {
                statusIndicator.className = 'status-indicator status-connected';
                statusText.textContent = `Conectado: ${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
            } else {
                statusIndicator.className = 'status-indicator status-disconnected';
                statusText.textContent = 'Carteira não conectada';
            }
        }

        // Configurar event listeners
        function setupEventListeners() {
            logDebugMessage("Setting up event listeners...");
            document.getElementById('connect-wallet-btn').addEventListener('click', connectWallet);
            document.getElementById('upload-btn').addEventListener('click', uploadAndAnalyzeImageWithChainlink);
            document.getElementById('preview-btn').addEventListener('click', previewAnalysis);
            document.getElementById('confirm-analysis-btn').addEventListener('click', confirmAndExecuteChainlink);
            document.getElementById('create-metadata-btn').addEventListener('click', createMetadataAndMint);
            document.getElementById('toggle-debug').addEventListener('click', toggleDebugInfo);
            
            // Listen for changes on the contract address input to re-initialize provider
            document.getElementById('chainlink-contract-address').addEventListener('change', initializeProvider);
            logDebugMessage("Event listeners configured.");
        }

        // Upload de imagem para IPFS com fallback HTTP/1.1
        async function uploadToIPFS(file) {
            logDebugMessage("Starting IPFS upload...");
            const formData = new FormData();
            formData.append('file', file);

            // Lista de endpoints para tentar
            const endpoints = [
                'https://nft-fuji-minter.onrender.com/upload',
                'https://nft-fuji-minter.onrender.com/api/upload',
                'https://nft-fuji-minter.onrender.com/ipfs/upload'
            ];

            for (const endpoint of endpoints) {
                try {
                    logDebugMessage(`Trying endpoint: ${endpoint}`);
                    
                    // Primeira tentativa com configuração padrão
                    let response = await fetch(endpoint, {
                        method: 'POST',
                        body: formData,
                        headers: {
                            'Accept': 'application/json'
                        }
                    });

                    if (response.ok) {
                        const data = await response.json();
                        logDebugMessage(`IPFS upload response: ${JSON.stringify(data)}`);
                        
                        // Verificar se o hash existe e é válido
                        const hash = data.IpfsHash || data.ipfs_hash || data.hash || data.ipfsHash;
                        if (hash && hash.length > 0) {
                            logDebugMessage(`IPFS upload successful. Hash: ${hash}`);
                            return hash;
                        } else {
                            logDebugMessage(`IPFS upload returned invalid hash: ${hash}`);
                            throw new Error("Hash IPFS inválido retornado pelo servidor");
                        }
                    }

                    // Se falhou, tentar com headers específicos para HTTP/1.1
                    logDebugMessage(`First attempt failed with status ${response.status}, trying with HTTP/1.1 headers...`);
                    
                    response = await fetch(endpoint, {
                        method: 'POST',
                        body: formData,
                        headers: {
                            'Accept': 'application/json',
                            'Connection': 'close',
                            'Cache-Control': 'no-cache'
                        }
                    });

                    if (response.ok) {
                        const data = await response.json();
                        logDebugMessage(`IPFS upload fallback response: ${JSON.stringify(data)}`);
                        
                        // Verificar se o hash existe e é válido
                        const hash = data.IpfsHash || data.ipfs_hash || data.hash || data.ipfsHash;
                        if (hash && hash.length > 0) {
                            logDebugMessage(`IPFS upload successful with fallback. Hash: ${hash}`);
                            return hash;
                        } else {
                            logDebugMessage(`IPFS upload fallback returned invalid hash: ${hash}`);
                            throw new Error("Hash IPFS inválido retornado pelo servidor (fallback)");
                        }
                    }

                } catch (error) {
                    logDebugMessage(`Endpoint ${endpoint} failed: ${error.message}`);
                    continue;
                }
            }

            // Se todos os endpoints falharam, tentar o endpoint de análise diretamente
            logDebugMessage("All upload endpoints failed, trying direct analysis...");
            throw new Error("Todos os endpoints de upload falharam. Tente usar a pré-visualização.");
        }

        // Pré-visualização da análise (chamada direta ao backend) com fallback
        async function previewAnalysis() {
            logDebugMessage("Starting preview analysis...");
            const fileInput = document.getElementById('image-upload');
            const file = fileInput.files[0];
            
            if (!file) {
                logDebugMessage("No file selected for preview.");
                alert('Por favor, selecione uma imagem primeiro.');
                return;
            }

            try {
                showLoading('Fazendo upload da imagem...');
                
                // Tentar upload para IPFS primeiro
                let ipfsHash;
                try {
                    ipfsHash = await uploadToIPFS(file);
                    currentImageHash = ipfsHash;
                    displayUploadedImage(file, ipfsHash);
                } catch (uploadError) {
                    logDebugMessage(`Upload failed: ${uploadError.message}`);
                    
                    // Se upload falhou, tentar análise direta com base64
                    showLoading('Upload falhou, tentando análise direta...');
                    
                    const base64 = await fileToBase64(file);
                    const analysisData = await analyzeImageDirect(base64);
                    
                    hideLoading();
                    displayPreviewAnalysis(analysisData);
                    
                    // Mostrar imagem sem IPFS hash
                    displayUploadedImage(file, 'Análise direta (sem IPFS)');
                    return;
                }
                
                showLoading('Analisando imagem com IA...');
                
                // Chamar backend para análise
                const analysisData = await analyzeImageByHash(ipfsHash);
                // Armazenar análise para uso posterior (se necessário)
                window.currentPreviewAnalysis = analysisData;
                
                logDebugMessage("Preview analysis completed successfully.");
                hideLoading();
                displayPreviewAnalysis(analysisData);
                
            } catch (error) {
                logDebugMessage(`Preview analysis failed: ${error.message}`);
                console.error('Erro na pré-visualização:', error);
                alert(`Erro na pré-visualização: ${error.message}`);
                hideLoading();
            }
        }

        // Converter arquivo para base64
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }

        // Análise de imagem por hash IPFS
        async function analyzeImageByHash(ipfsHash) {
            // Usando apenas o endpoint que funciona
            const endpoint = 'https://nft-fuji-minter.onrender.com/api/analyze-sentiment-chainlink';
            
            try {
                logDebugMessage(`Trying analysis endpoint: ${endpoint}`);
                
                const response = await fetch(endpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify({
                            image_hash: ipfsHash
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        logDebugMessage(`Analysis successful via ${endpoint}`);
                        return data;
                    } else {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                } catch (error) {
                    logDebugMessage(`Analysis endpoint failed: ${error.message}`);
                    throw new Error(`Endpoint de análise falhou: ${error.message}`);
                }
        }

        // Análise direta de imagem (fallback)
        async function analyzeImageDirect(base64Image) {
            logDebugMessage("Attempting direct image analysis...");
            
            // Simular análise local (placeholder)
            // Em uma implementação real, isso poderia chamar uma API alternativa
            return {
                sentiment_analysis: "Análise de sentimentos não disponível (modo offline)",
                color_psychology: "Análise de cores não disponível (modo offline)", 
                symbol_relation: "Análise simbólica não disponível (modo offline)",
                visual_language: "Análise visual não disponível (modo offline)",
                keywords: ["imagem", "análise", "offline"],
                attributes: {"modo": "offline", "status": "fallback"}
            };
        }

        // Exibir pré-visualização da análise
        function displayPreviewAnalysis(data) {
            logDebugMessage("Displaying preview analysis...");
            const previewContent = document.getElementById('preview-content');
            
            previewContent.innerHTML = `
                <div class="preview-item">
                    <h5><i class="fas fa-smile me-2"></i>Análise de Sentimentos</h5>
                    <p>${data.sentiment_analysis || 'N/A'}</p>
                </div>
                <div class="preview-item">
                    <h5><i class="fas fa-palette me-2"></i>Psicologia das Cores</h5>
                    <p>${data.color_psychology || 'N/A'}</p>
                </div>
                <div class="preview-item">
                    <h5><i class="fas fa-lightbulb me-2"></i>Relação Simbólica</h5>
                    <p>${data.symbol_relation || 'N/A'}</p>
                </div>
                <div class="preview-item">
                    <h5><i class="fas fa-eye me-2"></i>Linguagem Visual</h5>
                    <p>${data.visual_language || 'N/A'}</p>
                </div>
                <div class="preview-item">
                    <h5><i class="fas fa-tags me-2"></i>Palavras-chave</h5>
                    <p>${Array.isArray(data.keywords) ? data.keywords.join(', ') : (data.keywords || 'N/A')}</p>
                </div>
                <div class="preview-item">
                    <h5><i class="fas fa-info-circle me-2"></i>Atributos</h5>
                    <p>${Array.isArray(data.attributes) ? JSON.stringify(data.attributes, null, 2) : (data.attributes || 'N/A')}</p>
                </div>
            `;
            
            document.getElementById('analysis-preview').style.display = 'block';
            document.getElementById('analysis-preview').scrollIntoView({ behavior: 'smooth' });
        }

        // Confirmar e executar via Chainlink Functions
        async function confirmAndExecuteChainlink() {
            logDebugMessage("Confirming and executing via Chainlink Functions...");
            
            // Validar se temos um hash válido
            if (!currentImageHash || currentImageHash === 'undefined' || currentImageHash.length === 0) {
                logDebugMessage(`Invalid currentImageHash: ${currentImageHash}`);
                alert('Erro: Hash da imagem não encontrado ou inválido. Faça o upload novamente.');
                return;
            }

            try {
                await executeChainlinkFunction(currentImageHash);
            } catch (error) {
                logDebugMessage(`Chainlink execution failed: ${error.message}`);
                console.error('Erro na execução Chainlink:', error);
                alert(`Erro na execução Chainlink: ${error.message}`);
            }
        }

        // Executar função Chainlink
        async function executeChainlinkFunction(ipfsHash) {
            logDebugMessage("Executing Chainlink Function...");
            
            // Validar hash IPFS antes de prosseguir
            if (!ipfsHash || ipfsHash === 'undefined' || ipfsHash.length === 0) {
                logDebugMessage(`Invalid IPFS hash provided: ${ipfsHash}`);
                throw new Error("Hash IPFS inválido. Não é possível executar Chainlink Functions sem um hash válido.");
            }
            
            // Verificar se a carteira está conectada
            if (!currentProvider || !currentSigner) {
                logDebugMessage("Provider or Signer not initialized. Attempting to connect wallet.");
                await connectWallet();
                if (!currentProvider || !currentSigner) {
                    throw new Error("Carteira não conectada ou provedor não inicializado.");
                }
            }

            // Verificar se o contrato está configurado
            const contractAddress = document.getElementById('chainlink-contract-address').value;
            if (!contractAddress || contractAddress.length !== 42 || !contractAddress.startsWith('0x')) {
                logDebugMessage(`Invalid Chainlink Contract Address: ${contractAddress}`);
                throw new Error("Endereço do contrato Chainlink Functions inválido.");
            }

            if (!chainlinkContract) {
                await initializeProvider();
                if (!chainlinkContract) {
                    throw new Error("Contrato Chainlink Functions não inicializado.");
                }
            }

            showLoading('Executando via Chainlink Functions...');
            logDebugMessage(`Calling sendRequest on Chainlink Contract with IPFS Hash: ${ipfsHash}`);

            // Obter configurações de gas
            const gasLimit = parseInt(document.getElementById('gas-limit').value) || 15000000;
            const gasPrice = ethers.utils.parseUnits(document.getElementById('gas-price').value || '25', 'gwei');
            const subscriptionId = parseInt(document.getElementById('subscription-id').value) || 15580;
            
            logDebugMessage(`Gas configuration - Limit: ${gasLimit}, Price: ${gasPrice.toString()}, Subscription: ${subscriptionId}`);

            // Argumentos para a requisição Chainlink Functions - validar antes de usar
            const args = [ipfsHash];
            logDebugMessage(`Arguments for Chainlink Functions: ${JSON.stringify(args)}`);

            try {
                // Preparar parâmetros para sendRequest
                const source = `// O argumento é o IPFS hash enviado (args[0])
const imageHash = args[0];

if (!secrets.openaiKey) {
    throw Error("Need to set OPENAI_KEY environment variable");
}

const prompt = \`Analyze the sentiment and visual characteristics of an NFT image with IPFS hash: \${imageHash}.
Provide a detailed analysis in the following JSON format:
{
"sentiment_analysis": "detailed emotional analysis of the image",
"color_psychology": "analysis of colors and their psychological impact",
"symbol_relation": "symbolic meaning and cultural references",
"visual_language": "description of visual elements and composition",
"keywords": ["keyword1", "keyword2", "keyword3"],
"attributes": [{"trait_type": "Emotion", "value": "Joy"}, {"trait_type": "Style", "value": "Abstract"}]
}
Respond only with valid JSON.\`;

const openAIRequest = Functions.makeHttpRequest({
    url: "https://api.openai.com/v1/chat/completions",
    method: "POST",
    headers: {
        "Authorization": \`Bearer \${secrets.openaiKey}\`,
        "Content-Type": "application/json"
    },
    data: {
        model: "gpt-3.5-turbo",
        messages: [
            {"role": "system", "content": "You are an expert NFT and art analyst. Analyze images and provide detailed sentiment analysis in JSON format."},
            {"role": "user", "content": prompt}
        ],
        max_tokens: 1000,
        temperature: 0.7
    }
});

const [openAiResponse] = await Promise.all([openAIRequest]);

if (!openAiResponse || !openAiResponse.data || !openAiResponse.data.choices || !openAiResponse.data.choices[0]) {
    throw Error("Resposta inválida da OpenAI API");
}

const result = openAiResponse.data.choices[0].message.content;
return Functions.encodeString(result);`;

                const secretsLocation = 1; // DONHosted
                const encryptedSecretsReference = "0x"; // Empty for DONHosted
                const args = [ipfsHash];
                const bytesArgs = [];
                const callbackGasLimit = 300000;

                logDebugMessage(`Calling sendRequest with parameters:`);
                logDebugMessage(`- subscriptionId: ${subscriptionId}`);
                logDebugMessage(`- args: ${JSON.stringify(args)}`);
                logDebugMessage(`- callbackGasLimit: ${callbackGasLimit}`);

                // Enviar a requisição para o contrato Chainlink Functions
                const transaction = await chainlinkContract.sendRequest(
                    source,
                    secretsLocation,
                    encryptedSecretsReference,
                    args,
                    bytesArgs,
                    subscriptionId,
                    callbackGasLimit,
                    { 
                        gasLimit: gasLimit,
                        gasPrice: gasPrice
                    }
                );
                
                logDebugMessage(`Transaction sent. Hash: ${transaction.hash}`);
                showLoading(`Transação enviada: ${transaction.hash}. Aguardando confirmação...`);

                const receipt = await transaction.wait();
                logDebugMessage(`Transaction confirmed. Block: ${receipt.blockNumber}`);
                showLoading('Transação confirmada. Aguardando resultados da análise...');

                // O resultado será recebido via evento 'Response' no listener configurado

            } catch (error) {
                logDebugMessage(`Chainlink Function execution failed: ${error.message}`);
                throw error;
            }
        }

        // Função principal de upload e análise com Chainlink Functions
        async function uploadAndAnalyzeImageWithChainlink() {
            logDebugMessage("uploadAndAnalyzeImageWithChainlink called.");
            const fileInput = document.getElementById('image-upload');
            const file = fileInput.files[0];
            
            if (!file) {
                logDebugMessage("No file selected.");
                alert('Por favor, selecione uma imagem primeiro.');
                return;
            }

            try {
                showLoading('Preparando upload...');
                logDebugMessage("Loading spinner shown.");
                
                // Upload para IPFS
                const ipfsHash = await uploadToIPFS(file);
                currentImageHash = ipfsHash;
                
                // Mostrar imagem carregada
                displayUploadedImage(file, ipfsHash);
                
                // Executar função Chainlink
                await executeChainlinkFunction(ipfsHash);

            } catch (error) {
                logDebugMessage(`Análise de sentimentos falhou: ${error.message}`);
                console.error('Erro na análise:', error);
                alert(`Erro na análise: ${error.message}. Verifique o console para mais detalhes.`);
                hideLoading();
            }
        }

        // Exibir imagem carregada
        function displayUploadedImage(file, ipfsHash) {
            logDebugMessage("Displaying uploaded image...");
            const reader = new FileReader();
            reader.onload = function(e) {
                document.getElementById('uploaded-image').src = e.target.result;
                document.getElementById('ipfs-hash').textContent = ipfsHash;
                document.getElementById('image-preview').style.display = 'block';
                document.getElementById('preview-btn').style.display = 'block';
            };
            reader.readAsDataURL(file);
        }

        // Função para exibir os resultados da análise
        function displayAnalysisResults(sentiment, color, symbol, visual, keywords, attributes) {
            logDebugMessage("Displaying analysis results...");
            document.getElementById('sentiment-result').innerHTML = `<h4><i class="fas fa-smile me-2"></i>Análise de Sentimentos:</h4><p>${sentiment}</p>`;
            document.getElementById('color-result').innerHTML = `<h4><i class="fas fa-palette me-2"></i>Psicologia das Cores:</h4><p>${color}</p>`;
            document.getElementById('symbol-result').innerHTML = `<h4><i class="fas fa-lightbulb me-2"></i>Relação Simbólica:</h4><p>${symbol}</p>`;
            document.getElementById('visual-result').innerHTML = `<h4><i class="fas fa-eye me-2"></i>Linguagem Visual:</h4><p>${visual}</p>`;
            document.getElementById('keywords-result').innerHTML = `<h4><i class="fas fa-tags me-2"></i>Palavras-chave:</h4><p>${keywords}</p>`;
            document.getElementById('attributes-result').innerHTML = `<h4><i class="fas fa-info-circle me-2"></i>Atributos:</h4><p>${attributes}</p>`;
            document.getElementById('analysis-results').style.display = 'block';
            document.getElementById('analysis-preview').style.display = 'none';
            logDebugMessage("Analysis results displayed.");
        }

        // Função para criar metadados e mintar NFT
        async function createMetadataAndMint() {
            logDebugMessage("createMetadataAndMint called.");
            alert('Funcionalidade de criação de metadados e mintagem de NFT será implementada em breve.');
        }

        // Funções de UI
        function showLoading(message) {
            document.getElementById('loading-spinner').style.display = 'block';
            document.getElementById('loading-text').textContent = message;
            logDebugMessage(`Loading: ${message}`);
        }

        function hideLoading() {
            document.getElementById('loading-spinner').style.display = 'none';
            logDebugMessage("Loading hidden.");
        }

        function toggleDebugInfo() {
            const debugInfo = document.getElementById('debug-info');
            debugInfo.style.display = debugInfo.style.display === 'none' ? 'block' : 'none';
            logDebugMessage(`Debug info visibility toggled to: ${debugInfo.style.display}`);
        }

        // Inicialização quando o DOM estiver carregado
        document.addEventListener('DOMContentLoaded', function() {
            logDebugMessage("DOM Content Loaded. Initializing...");
            setupEventListeners();
            checkWalletConnection();
        });
    </script>
</body>
</html>

